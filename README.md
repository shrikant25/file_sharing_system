Check queries_explanation.txt for detailed info.

This system, composed of various processes, is used to transmit data over a network. It includes eight different user processes and a database. Data processing occurs within the database, while the user processes handle sending and receiving data over the network.

Terms like "message" and "job" fundamentally represent individual rows in tables.

Every system listens on two ports: a fixed port for consensus forming (commsport) and a variable port for data communication (dataport). The IP address of the system remains constant in both cases. This data is stored in the selfinfo table within the database. The reason for keeping the dataport variable is to support future modifications, allowing one system to listen on multiple ports.

To send data, two systems form a consensus using the commsport regarding the message size and the port for communication. Since the commsport is a fixed port, it is assumed that all systems are listening on this port for consensus-related messages. Only the IP address of the system is required.

Suppose there are two systems, S1 and S2. If S1 intends to send data to S2, it first checks its database for the required information about S2. If the information is available, S1 proceeds with sending the message. If not, S1's database creates a fixed-size message containing its IP address, dataport, and sending capacity. The initial_sender process of S1 reads this message and sends it to S2's commsport, given that S1 knows S2's IP address. The message is received by the initial_receiver process of S2 and stored in its database. The databases of S1 and S2 compare their message capacities, and S2 finalizes the message size based on the smaller capacity. S2 then updates its sysinfo table with S1's dataport, the finalized message size, and S1's IP address and commsport. S2 prepares a message for S1 with its own IP address, dataport, and the finalized message size, which is sent back to S1. Upon receipt, S1 updates its sysinfo table with S2's information. Both systems' processor_r processes receive a message from their respective databases after updating the sysinfo table. The processor_r process sends this message to the receiver process via shared memory. The message includes the IP address and message size for the process with the updated sysinfo table entry. The receiver process then creates an entry in a hashtable where the key is the IP address and the value is the message size. This allows the receiver to instantly access the message size and read messages of that size from the incoming port when a connection is opened.

To send a message from S1 to S2, first import the file into S1's files table, then create a job to send the specified file to S2. These steps can be performed using a user program.

Once the job is created, and there is already a consensus between S1 and S2 on the message size, S1's database checks the file size and splits it into chunks of ceil(file_size/message_size). Each chunk gets its own header indicating its serial number and parent ID. A separate message with information about the chunks, such as chunk count and original message size, is also created. The parent ID identifies chunks belonging to the same original message. The database sends a message to the processor_s process, which then sends the message to the sender, including the IP address and port. The sender attempts to open a connection to the given IP address and port. If successful, the sender sends a connection status message to processor_s, which stores it in the database. If successful, the message includes the file descriptor and IP address of the socket; otherwise, it includes -1 and the IP address.

If a connection is open and there are messages to be sent, processor_s reads these messages along with the file descriptor for the connection socket. The message is sent to the sender via shared memory. The sender attempts to send the message and updates the database with the message status. On the receiving system's side, the receiver process reads the data. Once data equal to the message_size is read, the message is passed to processor_r, which stores it in the database.

Messages in the database go through various states. A parent message persists throughout the system's lifetime, always in the N-O state. Any newly arrived message is in the N-1 state. If the message hash matches, it is promoted to the N-2 state; otherwise, it moves to the dead state (D). If the message is intended for another system, it is promoted to the S-1 state; if for the same system, it is promoted to the N-3 state. In N-3, the message type is identified and promoted to N-4. Actions in N-4 depend on the message type.

Type 1: Single-piece message (no chunks).
Type 2: Chunk of a larger message.
Type 3: Information about chunks of a larger message.
Type 4: Initial message to create consensus.
Type 5: Reply to a Type 4 message.
Type 6: Job created to send data from one system to another.
For messages in the S-1 state, the sysinfo table is checked for the destination system's message size capacity. If unavailable, a job is created to form a consensus on message size. If available, and the message needs to be divided into chunks, it is promoted to the S-2 state. In S-2, chunks are created and kept in S-4, while the main message moves to S-2W until all chunks are successfully sent. If chunk sending fails, the message moves to the dead state (D). Messages that fit the message size are directly promoted to S-4. Processor_r picks up messages from S-4 for destinations with an open connection. Consensus-forming messages move to S-5 and are picked up by the initial_sender.

For any errors in any processes, log entries are made in the logs table. Errors occurring before database connection are stored in syslog.
